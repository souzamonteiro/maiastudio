/**
 * license
 * Copyright 2020 Roberto Luiz Souza Monteiro,
 *                Renata Souza Barreto,
 *                Hernane Borges de Barros Pereira.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at;
 *
 *   http://www.apache.org/licenses/LICENSE-2.0;
 *
 * Unless required by applicable law or agreed to in writing, software;
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, eitherMath.express or implied.
 * See the License for the specific language governing permissions and;
 * limitations under the License.
 */

/**
 * MaiaScript Social and Complex Network Analysis library.
 * @class cna
 */
namespace cna {
    /**
     * Creates a Pajek file.
     * @method createPajekFile
     * @param {object}   adj - Adjascence matrix.
     * @param {string}   type - File type.
     * @return {string}  A Pajek file.
     */
    function createPajekFile = dim(adj, type) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        // Each line in a Pajek files must terminate with CR+LF.
        newLine = "\r\n"
        // Save vertices.
        fileContents = "*Vertices " + (dimI - 1) + newLine
        for (i = 1; i < dimI; i = i + 1) {
            fileContents = fileContents + i + " \"" + adj[i, 0] + "\"" + newLine
        }
        // Save edges.
        if (type == "edges") {
            fileContents = fileContents + "*Edges" + newLine
            for (i = 1; i < dimI; i = i + 1) {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[i, j] != 0) {
                        fileContents = fileContents + i + " " + j + " " + adj[i, j] + newLine
                    }
                }
            }
        // Save arcs.
        } elseif (type == "arcs") {
            fileContents = fileContents + "*Arcs" + newLine
            for (i = 1; i < dimI; i = i + 1) {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[i, j] != 0) {
                        fileContents = fileContents + i + " " + j + " " + adj[i, j] + newLine
                    }
                }
            }
        // Save matrix.
        } elseif (type == "matrix") {
            fileContents = fileContents + "*Matrix" + newLine
            for (i = 1; i < dimI; i = i + 1) {
                for (j = 1; j < dimJ; j = j + 1) {
                    fileContents = fileContents + " " + adj[i, j]
                }
                fileContents = fileContents + newLine
            }
        }
        return(fileContents)
    }
    
    /**
     * Parses a Pajek file.
     * @method parsePajekFile
     * @param {string}   fileContents - Pajek file contents.
     * @return {object}  An adjascence matrix.
     */
    function parsePajekFile(fileContents) {
        fileSection = "none"
        fileLines = core.split(fileContents, "\r\n")
        for (l = 0; l < fileLines.length; l = l + 1) {
            line = fileLines[l]
            record = core.split(line.trim(), " ")
            if ((core.toLowerCase(record[0]) == "*vertices") || (core.toLowerCase(record[0]) == "*edges") || (core.toLowerCase(record[0]) == "*arcs") || (core.toLowerCase(record[0]) == "*matrix")) {
                fileSection = core.toLowerCase(record[0])
                if (fileSection == "*vertices") {
                    n = core.toNumber(record[1]) + 1
                    adj = core.matrix(0, n, n)
                }
                i = 0
                continue
            }
            if (fileSection == "*vertices") {
                adj[0, i + 1] = core.toNumber(record[1])
                adj[i + 1, 0] = core.toNumber(record[1])
                i = i + 1
            } elseif (fileSection == "*edges") {
                i = core.toNumber(record[0])
                j = core.toNumber(record[1])
                if (length(record) == 2) {
                    adj[i, j] = 1
                    adj[j, i] = 1
                } else {
                    adj[i, j] = core.toNumber(record[2])
                    adj[j, i] = core.toNumber(record[2])
                }
            } elseif (fileSection == "*arcs") {
                i = core.toNumber(record[0])
                j = core.toNumber(record[1])
                if (core.length(record) == 2) {
                    adj[i, j] = 1
                } else {
                    adj[i, j] = core.toNumber(record[2])
                }
            } elseif (fileSection == "*matrix") {
                for (j = 0; j < record.length; j = j + 1) {
                    v = record[j]
                    adj[i + 1, j + 1] = core.toNumber(v)
                    if (i == n) {
                        break
                    }
                }
                i = i + 1
            }
        }
        return(adj)
    }
    
    /**
     * Transitive closure between two matrices (A and B).
     * @method getTransitiveClosure
     * @param {object}   a - Matrix A.
     * @param {object}   b - Matrix B.
     * @return {object}  Transitive closing between two matrices.
     */
    function getTransitiveClosure(a, b) {
        dimA = core.dim(A)
        dimB = core.dim(B)
        if (dimA[1] == dimB[0]) {
            c = core.matrix(0, dimA[1], dimB[0])
            for (i = 0; i < dimA[0]; i = i + 1) {
                for (j = 0; j < dimB[1]; j = j + 1) {
                    s = 0
                    for (k = 0; k < dimB[0]; k = k + 1) {
                        s = s || (a[i,k] && b[k,j])
                    }
                    c[i,j] = s
                }
            }
            return(c)
        } else {
            throw(Error("The number of columns in matrix A must equal the number of rows in matrix B"))
        }
    }
    
    /**
     * Boolean OR between two matrices (A and B).
     * @method getBooleanOr
     * @param {object}   a - Matrix A.
     * @param {object}   b - Matrix B.
     * @return {object}  Boolean OR between two matrices.
     */
    function getBooleanOr(a, b) {
        dimA = core.dim(A)
        dimB = core.dim(B)
        if (dimA == dimB) {
            c = core.matrix(0, dimA[0], dimA[1])
            for (i = 0; i < dimA[0]; i = i + 1) {
                for (j = 0; j < dimA[1]; j = j + 1) {    
                    c[i,j] = a[i, j] || b[i, j]
                }
            }
            return(c)
        } else {
            throw(Error("The dimensions of matrix A must be the same as that of matrix B"))
        }
    }
    
    /**
     * Calculates the network density.
     * @method getDensity
     * @param {object}   adj - Adjascence matrix.
     * @param {boolean}  directed - True if the network is directed.
     * @return {number}  The network density.
     */
    function getDensity(adj, directed) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        n = dimI - 1
        // Remove vertex data from the matrix.
        for (i = 0; i < dimI; i = i + 1) {
            adj[0, i] = 0
            adj[i, 0] = 0
        }
        nedges = matrix.count(adj)
        if (directed) {
            density = nedges / (n * (n - 1))
        } else {
            density = (nedges / 2.0) / ((n * (n - 1)) / 2.0)
        }
        return(density)
    }
    
    /**
     * Calculates the degrees of the vertices of the matrix.
     * @method getDegrees
     * @param {object}   adj - Adjascence matrix.
     * @param {boolean}  directed - True if the network is directed.
     * @return {object}  Returns a array containing the degrees of the vertices.
     */
    function getDegrees(adj, directed) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        degrees = core.matrix(0, dimI, 3)
        for (i = 1; i < dimI; i = i + 1) {
            degrees[i, 0] = matrix.count(adj, i, 1, i, dimJ - 1)
            degrees[i, 1] = matrix.count(adj, 1, i, dimI - 1, i)
            if (directed) {
                degrees[i, 2] = degrees[i, 0] + degrees[i, 1]
            } else {
                if (degrees[i, 0] != 0) {
                    degrees[i, 2] = degrees[i, 0]
                } else {
                    degrees[i, 2] = degrees[i, 1]
                }
            }
        }
        return(degrees)
    }
    
    /**
     * Calculates the degrees distribution in the network.
     * @method getDegreeDistribution
     * @param {object}   degrees - Array containing degrees of the vertices.
     * @return {object}  Returns an array containing the degrees distribution in the network.
     */
    function getDegreeDistribution(degrees) {
        dimDegrees = core.dim(degrees)
        dimI = dimDegrees[0]
        for (i = 1; i < dimI; i = i + 1) {
            degree = degrees[i, 2]
            if (core.type(degDist) == "undefined") {
                if (core.type(degDist[degree]) == "undefined") {
                    degDist[degree] = 1
                } else {
                    degDist[degree] = degDist[degree] + 1
    			}
            } else {
                degDist = []
                degDist[degree] = 1
            }
        }
        hist = core.matrix(0, length(degDist), 3)
        i = 0
        foreach(degDist; deg; dist) {
            hist[i, 0] = deg
            hist[i, 1] = dist
    		i = i + 1
        }
        dimHist = core.dim(hist)
        sumDegs = matrix.sum(hist, 0, 1, dimHist[0] - 1, 1)
        for (i = 0; i < dimHist[0]; i = i + 1) {
            hist[i, 2] = (hist[i, 1] / sumDegs) * 100
        }
        // Sort data.
        for (i = 0; i < dimHist[0] - 1; i = i + 1) {
            for (j = i; j < dimHist[0]; j = j + 1) {
                if (hist[i, 0] > hist[j, 0]) {
                    degree = hist[i, 0]
                    hist[i, 0] = hist[j, 0]
                    hist[j, 0] = degree
                    
                    frequency = hist[i, 1]
                    hist[i, 1] = hist[j, 1]
                    hist[j, 1] = frequency

                    percentual = hist[i, 2]
                    hist[i, 2] = hist[j, 2]
                    hist[j, 2] = percentual
                }
            }
        }
    	return(hist)
    }
    
    /**
     * Calculates average degree of the network.
     * @method getAverageDegree
     * @param {object}   degrees - Array containing degrees of the vertices.
     * @return {number}  Returns the average degree of the network.
     */
    function getAverageDegree(degrees) {
        dimDegrees = core.dim(degrees)
        dimI = dimDegrees[0]
        avgDeg = avg(degrees, 1, 2, (dimI - 1), 2)
        return(avgDeg)
    }
    
    /**
     * Calculates the clustering coefficient of the vertices.
     * @method getClustering
     * @param {object}   adj - Adjascence matrix.
     * @param {boolean}  directed - True if the network is directed.
     * @return {object}  Returns an array containing the clustering coefficient of the vertices.
     */
    function getClustering(adj, directed) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        // To calculate the clustering coefficient we need an undirected graph.
        if (directed) {
            for (i = 1; i < dimI; i = i + 1) {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[i, j] == 1) {
                        adj[j, i] = 1
                    }
                }
            }
        }
        clustering = core.matrix(0, dimI, 1)
        // Calculate the clustering coefficient for each vertex.
        for (i = 1; i < dimI; i = i + 1) {
            ki = matrix.count(adj, i, 1, i, (dimJ - 1))
            // If the vertex has any neighbor.
            if (ki > 0) {
                // Get all neighbor indexes.
                ni = 0
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[i, j] == 1) {
                        neighbor[ni] = j
                        ni = ni + 1
                    }
                }
                n = 0
                if (core.type(neighbor) != "undefined") {
                    for (j = 1; j < dimJ; j = j + 1) {
                        if (adj[j, i] == 1) {
                            if (core.includes(neighbor, j)) {
                                neighbor[ni] = j
                                ni = ni + 1
                            }
                        }
                    }
                    // Calculate the number of neighbors connected one to other.
                    foreach(neighbor; n1; i1) {
                        foreach(neighbor; n2; j2) {
                            if (n1 != n2) {
                                if (adj[i1, j2] == 1) {
                                    n = n + 1
                                }
                            }
                        }
                    }
                    neighbor = null
                }
                // Calculate the clustering coefficient to this vertex.
                if ((ki == 0) || (ki == 1)) {
                    clustering[i, 0] = 0
                } else {
                    clustering[i, 0] = (n / 2.0) / (0.5 * (ki * (ki - 1)))
                }
            }
        }
        return(clustering)
    }
    
    /**
     * Calculates average clustering coefficient of the network.
     * @method getAverageClustering
     * @param {object}   degrees - Array containing the clustering coefficients of the vertices
     * @return {number}  Returns the average clustering coefficient of the network.
     */
    function getAverageClustering(clustering) {
        dimClustering = core.dim(clustering)
        n = dimClustering[0] - 1
        avgClustering = (1.0 / n) * matrix.sum(clustering)
        return(avgClustering)
    }
    
    /**
     * Calculates the shortest parh between each two vetices in the matrix.
     * @method getShortestPath
     * @param {object}   adj - Adjascence matrix.
     * @return {object}  Returns an array containing the shortest parh between each two vetice in the matrix.
     */
    function getShortestPath(adj) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        matrixOne = matrix.one(dimI, dimJ)
        matrixZero = matrix.zero(dimI, dimJ)   
        // Remove vertex data from the matrix.
        for (i = 0; i < dimI; i = i + 1) {
            adj[0, i] = 0
            adj[i, 0] = 0
            matrixOne[0, i] = 0
            matrixOne[i, 0] = 0
        } 
        geodesic = adj
        if ((adj == matrixZero) || (adj == matrixOne)) {
            return(geodesic)
        }
        old = core.new(adj)
        prod = core.new(adj)
        order = 1
        while (TRUE) {
            prod = getTransitiveClosure(adj, old)
            path = getBooleanOr(old, prod)
            order = order + 1      
            for (i = 1; i < dimI; i = i + 1) {
                for (j = 1; j < dimJ; j = j + 1) {
                    if ((prod[i, j] == 1) && (geodesic[i, j] == 0) && (i != j)) {
                        geodesic[i, j] = order
                    }
                }
            } 
            if (path == matrixOne) {
                break
            } elseif (path == old) {
                break
            } elseif (order == dimI) {
                break
            }
            old = prod
        }
        return(geodesic)
    }
    
    /**
     * Calculates average shortest path of the network.
     * @method getAverageShortestPath
     * @param {object}   geodesic - Array the shortest parh between each two vetices in the matrix.
     * @return {number}  Returns the average shortest path of the network.
     */
    function getAverageShortestPath(geodesic) {
        dimGeodesic = core.dim(geodesic)
        dimI = dimGeodesic[0]
        dimJ = dimGeodesic[1]
        n = count(geodesic, 1, 1, dimI - 1, dimJ - 1)
        if (n > 0) {
            avgshortestpath = sum(geodesic, 1, 1, dimI - 1, dimJ - 1) / n
        } else {
            avgshortestpath = 0
        }
        return(avgshortestpath)
    }
    
    /**
     * Calculates the network diameter.
     * @method getDiameter
     * @param {object}   geodesic - Array the shortest parh between each two vetices in the matrix.
     * @return {number}  Returns the network diameter.
     */
    function getDiameter(geodesic) {
        diameter = matrix.max(geodesic)
        return(diameter)
    }
    
    /**
     * Calculates the shortest parh between each two vetices in the matrix using Floyd Warshall method.
     * @method getFloydWarshallShortestPath
     * @param {object}   adj - Adjascence matrix.
     * @return {object}  Returns an array containing the shortest parh between each two vetice in the matrix.
     */
    function getFloydWarshallShortestPath(adj, path = "") {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        geodesic = adj
        if (path != "") {
            path = core.matrix(-1, dimI, dimJ)
        }
        for (i = 1; i < dimI; i = i + 1) {
            for (j = 1; j < dimJ; j = j + 1) {
                for (k = 1; k < dimI; k = k + 1) {
                    if (geodesic[j, k] == 0) {
                        geodesic[j, k] = 999999999
                    }
                    if (geodesic[j, i] == 0) {
                        geodesic[j, i] = 999999999
                    }
                    if (geodesic[i, k] == 0) {
                        geodesic[i, k] = 999999999
                    }
                    if ((geodesic[j, i] + geodesic[i, k]) < geodesic[j, k]) {
                        geodesic[j, k] = geodesic[j, i] + geodesic[i, k]
                        if (path != "") {
                            path[j, k] = i
                        }
                    }
                }
            }
        }
        for (i = 0; i < dimI; i = i + 1) {
            geodesic[0, i] = 0
            geodesic[i, 0] = 0
            geodesic[i, i] = 0
        }
        // Fix geodesics.
        for (i = 0; i < dimI; i = i + 1) {
            for (j = 0; j < dimJ; j = j + 1) {
                if (geodesic[i, j] == 999999999) {
                    geodesic[i, j] = 0
                }
            }
        }
        return(geodesic)
    }
    
    /**
     * Do a shortest parh walk in the network and returns the path.
     * @method doShortestPathWalk
     * @param {object}   adj - Adjascence matrix.
     * @return {object}  Returns an array containing the shortest parh walk between each two vetice in the matrix.
     */
    function doShortestPathWalk(geodesic, path, j, k) {
        if (geodesic[j, k] == 0) {
            return("")
        }
        i = path[j, k]
        if (i == -1) {
            return("")
        } else {
            pji = doShortestPathWalk(geodesic, path, j, i)
            pik = doShortestPathWalk(geodesic, path, i, k)
            pjk = ""
            if (pji != "") {
                pjk = pjk + pji + ", "
            }
            pjk = pjk + i
            if (pik != "") {
                pjk = pjk + ", " + pik
            }
            return(pjk)
        }
        return(path)
    }
    
    /**
     * Return the number os geodesics in the network.
     * @method getNumberOfGeodesics
     * @param {object}   adj - Adjascence matrix.
     * @param {object}   geodesic - Vector including the geodesics of the network.
     * @param {boolean}  directed - True if the network is directed. False otherwise.
     * @return {number}  Returns the number os geodesics in the network.
     */
    function getNumberOfGeodesics(adj, geodesic, directed) {
        dimGeodesic = core.dim(geodesic)
        dimI = dimGeodesic[0]
        dimJ = dimGeodesic[1]
        gjk = adj
        for (i = 0; i < dimI; i = i + 1) {
            gjk[0, i] = 0
            gjk[i, 0] = 0
            gjk[i, i] = 1
        }
        diameter = getDiameter(geodesic)
        // Count how many geodesics are there between vertices i and j.
        for (p = 2; p <= diameter; p = p + 1) {
            npaths = adj ** p
            for (i = 1; i < dimI; i = i + 1) {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (i != j) {
                        if (gjk[i, j] == 0) {
                            gjk[i, j] = npaths[i, j]
                        }
                    }
                }
            }
        return(gjk)
    }
    
    /**
     * Returns an array containing the centralities of each pair of the network's vertices.
     * @method getCentrality
     * @param {object}   adj - Adjascence matrix.
     * @param {object}   geodesic - Vector including the geodesics of the network.
     * @param {boolean}  directed - True if the network is directed. False otherwise.
     * @return {object}  Returns an array containing the centralities of each pair of the network's vertices
     */
    function getCentrality(adj, geodesic, directed) {
        dimGeodesic = core.dim(geodesic)
        dimI = dimGeodesic[0]
        dimJ = dimGeodesic[1]
        // Column 0 contains the closeness centrality,
        // Column 1 contains the betweenness centrality.
        // Column 2 contains the normalized closeness centrality,
        // Column 3 contains the normalized betweenness centrality.
        centrality = core.matrix(0, dimI, 5)
        n = dimI - 1
        // Calculate the closeness centrality for each vertex.
        for (i = 1; i < dimI; i = i + 1) {
            s = matrix.sum(geodesic, i, 1, i, dimJ - 1)
            if (s > 0) {
                centrality[i, 0] = 1.0 / s
                centrality[i, 2] = (n - 1.0) / s
                centrality[i, 4] = s
            }
        }
        // Calculate the betweenness centrality for each vertex.
        gjk = getNumberOfGeodesics(adj, geodesic, directed)
        for (i = 1; i < dimI; i = i + 1) {
            bc = 0
            for (j = 1; j < dimI; j = j + 1) {
                for (k = 1; k < dimJ; k = k + 1) {
                    // Must insert an if to test if it is a directed graph.
                    if ((j < k) && (j != i) && (i != k)) {
                        spjk = geodesic[j, k]
                        if ((geodesic[j, i] + geodesic[i, k]) == spjk) {
                            bc = bc + (Math.max(gjk[j, i], gjk[i, k]) / (gjk[j, k]))
                        }
                    }
                }
            }
            centrality[i, 1] = bc
            centrality[i, 3] = (2.0 * bc) / (n ** 2 - 3 * n + 2)
        }
        return(centrality)
    }
    
    /**
     * Returns an array containing the vertex efficiency of each pair of the network's vertices.
     * @method getVertexEfficiency
     * @param {object}   adj - Adjascence matrix.
     * @param {object}   geodesic - Vector including the geodesics of the network.
     * @param {boolean}  directed - True if the network is directed. False otherwise.
     * @return {object}  Returns an array containing the vertex efficiency of each pair of the network's vertices
     */
    function getVertexEfficiency(geodesic) {
        dimGeodesic = core.dim(geodesic)
        dimI = dimGeodesic[0]
        dimJ = dimGeodesic[1]
        efficiency = core.matrix(0, dimI, dimJ)
        for (i = 1; i < dimI; i = i + 1) {
            for (j = 1; j < dimJ; j = j + 1) {
                if (geodesic[i , j] != 0) {
                    efficiency[i, j] = 1.0 / geodesic[i , j]
                }
            }
        }
        return(efficiency)
    }
    
    /**
     * Returns the network's global efficiency.
     * @method getGlobalEfficiency
     * @param {object}   efficiency - Array containing the vertex efficiency of each vertex of the network.
     * @return {number}  Returns the network's global efficiency.
     */
    function getGlobalEfficiency(efficiency) {
        dimEfficiency = core.dim(efficiency)
        n = dimEfficiency[0] - 1
        avgeff = (1.0 / (n * (n - 1))) * matrix.sum(efficiency)
        return(avgeff)
    }
    
    /**
     * Returns the network's subgraphs efficiencies.
     * @method getSubgraphEfficiency
     * @param {object}   adj - Adjascence matrix.
     * @param {object}   efficiency - Array containing the vertex efficiency of each vertex of the network.
     * @return {object}  Returns the network's subgraphs efficiencies.
     */
    function getSubgraphEfficiency(adj, efficiency) {
        dimAdj = core.dim(adj)
        dimEfficiency = core.dim(efficiency)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        subgraphEfficiency = core.matrix(0, dimI, 1)
        // Calculate the local efficiency for each vertex.
        for (i = 1; i < dimI; i = i + 1) {
            // Get all neighbor indexes.
            n = 0
            for (j = 1; j < dimJ; j = j + 1) {
                if (adj[i, j] == 1) {
                    neighbor[n] = j
                    n = n + 1
                }
            }
            if (core.type(neighbor) != "undefined") {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[j, i] == 1) {
                        if (!neighbor.includes(j)) {
                            neighbor[n] = j
                            n = n + 1
                        }
                    }
                }
            }
            // Sum all neighbors efficiency.
            if (core.type(neighbor) != "undefined") {
                s = 0.0
                foreach(neighbor; n1; i1) {
                    foreach(neighbor; n2; j2) {
                        s = s + efficiency[i1, j2]
                    }
                }
                n = core.length(neighbor)
                neighbor = null
                // Calculate the local efficiency to this vertex...
                if ((n == 0) || (n == 1)) {
                    subgraphEfficiency[i, 0] = 0.0
                } else {
                    subgraphEfficiency[i, 0] = (1.0 / (n * (n - 1))) * s
                }
            }
        }
        return(subgraphEfficiency)
    }
    
    /**
     * Returns the network's subgraphs efficiencies using Latora and Marchiori method.
     * @method getLatoraSubgraphEfficiency
     * @param {object}   adj - Adjascence matrix.
     * @return {object}  Returns the network's subgraphs efficiencies.
     */
    function getLatoraSubgraphEfficiency(adj) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        subgraphEfficiency = core.matrix(0, dimI, 1)
        // Calculate the local efficiency for each vertex.
        for (i = 1; i < dimI; i = i + 1) {
            // Get all neighbor indexes.
            n = 0
            for (j = 1; j < dimJ; j = j + 1) {
                if (adj[i, j] == 1) {
                    neighbor[n] = j
                    n = n + 1
                }
            }
            if (core.type(neighbor) != "undefined") {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[j, i] == 1) {
                        if (!neighbor.includes(j)) {
                            neighbor[n] = j
                            n = n + 1
                        }
                    }
                }
            }
            // Calculate the vertex efficiency.
            temp = core.new(adj)
            for (k = 1; k < dimI; k = k + 1) {
                temp[i, k] = 0
                temp[k, i] = 0
            }
            if (core.type(neighbor) != "undefined") {
                for (k = 1; k < dimI; k = k + 1) {
                    if (!neighbor.includes(k)) {
                        for (j = 1; j < dimJ; j = j + 1) {
                            temp[j, k] = 0
                            temp[k, j] = 0
                        }
                    }
                }
            }
            geodesic = getShortestPath(temp)
            efficiency = getVertexEfficiency(geodesic)
            // Sum all neighbors efficiency.
            if (core.type(neighbor) != "undefined") {
                s = 0.0
                foreach(neighbor; n1; i1) {
                    foreach(neighbor; n2; j2) {
                        s = s + efficiency[i1, j2]
                    }
                }
                n = core.length(neighbor)
                neighbor = null
                // Calculate the local efficiency to this vertex.
                if ((n == 0) || (n == 1)) {
                    subgraphEfficiency[i, 0] = 0.0
                } else {
                    subgraphEfficiency[i, 0] = (1.0 / (n * (n - 1))) * s
                }
            }
        }
        return(subgraphEfficiency)
    }
    
    /**
     * Returns the network's subgraphs efficiencies using Latora and Marchiori method and Floyd Warshall algorithm.
     * @method getLatoraSubgraphEfficiency
     * @param {object}   adj - Adjascence matrix.
     * @return {object}  Returns the network's subgraphs efficiencies.
     */
    function getLatoraSubgraphEfficiencyFW(adj) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        subgraphEfficiency = core.matrix(0, dimI, 1)
        // Calculate the local efficiency for each vertex.
        for (i = 1; i < dimI; i = i + 1) {
            // Get all neighbor indexes.
            n = 0
            for (j = 1; j < dimJ; j = j + 1) {
                if (adj[i, j] == 1) {
                    neighbor[n] = j
                    n = n + 1
                }
            }
            if (core.type(neighbor) != "undefined") {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[j, i] == 1) {
                        if (search(neighbor, j) == NULL) {
                            neighbor[n] = j
                            n = n + 1
                        }
                    }
                }
            }
            // Calculate the vertex efficiency...
            temp = core.new(adj)
            for (k = 1; k < dimI; k = k + 1) {
                temp[i, k] = 0
                temp[k, i] = 0
            }
            if (core.type(neighbor) != "undefined") {
                for (k = 1; k < dimI; k = k + 1) {
                    if (!neighbor.includes(k)) {
                        for (j = 1; j < dimJ; j = j + 1) {
                            temp[j, k] = 0
                            temp[k, j] = 0
                        }
                    }
                }
            }
            geodesic = getFloydWarshallShortestPath(temp)
            efficiency = getVertexEfficiency(geodesic)
            // Sum all neighbors efficiency...
            if (core.type(neighbor) != "undefined") {
                s = 0.0
                foreach(neighbor; n1; i1) {
                    foreach(neighbor; n2; j2) {
                        s = s + efficiency[i1, j2]
                    }
                }
                n = core.length(neighbor)
                neighbor = null
                // Calculate the local efficiency to this vertex.
                if ((n == 0) || (n == 1)) {
                    subgraphEfficiency[i, 0] = 0.0
                } else {
                    subgraphEfficiency[i, 0] = (1.0 / (n * (n - 1))) * s
                }
            }
        }
        return(subgraphEfficiency)
    }
    
    /**
     * Returns the network's subgraphs plasticity efficiencies.
     * @method getPlasticitySubgraphEfficiency
     * @param {object}   adj - Adjascence matrix.
     * @return {object}  Returns the network's subgraphs plasticity efficiencies.
     */
    function getPlasticitySubgraphEfficiency(adj) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        subgraphEfficiency = core.matrix(0, dimI, 1)
        // Calculate the local efficiency for each vertex.
        for (i = 1; i < dimI; i = i + 1) {
            // Get all neighbor indexes.
            n = 0
            for (j = 1; j < dimJ; j = j + 1) {
                if (adj[i, j] == 1) {
                    neighbor[n] = j
                    n = n + 1
                }
            }
            if (core.type(neighbor) != "undefined") {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[j, i] == 1) {
                        if (!neighbor.includes(j)) {
                            neighbor[n] = j
                            n = n + 1
                        }
                    }
                }
            }
            // Calculate the vertex efficiency.
            temp = core.new(adj)
            for (k = 1; k < dimI; k = k + 1) {
                temp[i, k] = 0
                temp[k, i] = 0
            }
            geodesic = ShortestPath(temp)
            efficiency = VertexEfficiency(geodesic)
            // Sum all neighbors efficiency.
            if (core.type(neighbor) != "undefine") {
                s = 0.0
                foreach(neighbor; n1; i1) {
                    foreach(neighbor; n2; j2) {
                        s = s + efficiency[i1, j2]
                    }
                }
                n = core.length(neighbor)
                neighbor = null
                // Calculate the local efficiency to this vertex.
                if ((n == 0) || (n == 1)) {
                    subgraphEfficiency[i, 0] = 0.0
                } else {
                    subgraphEfficiency[i, 0] = (1.0 / (n * (n - 1))) * s
                }
            }
        }
        return(subgraphEfficiency)
    }
    
    /**
     * Returns the network's subgraphs plasticity efficiencies using Floyd Warshall algorithm.
     * @method getLatoraSubgraphEfficiency
     * @param {object}   adj - Adjascence matrix.
     * @return {object}  Returns the network's subgraphs plasticity efficiencies.
     */
    function getPlasticitySubgraphEfficiencyFW(adj) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        subgraphEfficiency = core.matrix(0, dimI, 1)
        // Calculate the local efficiency for each vertex.
        for (i = 1; i < dimI; i = i + 1) {
            // Get all neighbor indexes.
            n = 0
            for (j = 1; j < dimJ; j = j + 1) {
                if (adj[i, j] == 1) {
                    neighbor[n] = j
                    n = n + 1
                }
            }
            if (core.type(neighbor) != "undefined") {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[j, i] == 1) {
                        if (!neighbor.includes(j)) {
                            neighbor[n] = j
                            n = n + 1
                        }
                    }
                }
            }
            // Calculate the vertex efficiency.
            temp = core.new(adj)
            for (k = 1; k < dimI; k = k + 1) {
                temp[i, k] = 0
                temp[k, i] = 0
            }
            geodesic = floydWarshallShortestPath(temp)
            efficiency = vertexEfficiency(geodesic)
            // Sum all neighbors efficiency.
            if (core.type(neighbor) != "undefined") {
                s = 0.0
                foreach(neighbor; n1; i1) {
                    foreach(neighbor; n2; j2) {
                        s = s + efficiency[i1, j2]
                    }
                }
                n = core.length(neighbor)
                neighbor = null
                // Calculate the local efficiency to this vertex.
                if ((n == 0) || (n == 1)) {
                    subgraphEfficiency[i, 0] = 0.0
                } else {
                    subgraphEfficiency[i, 0] = (1.0 / (n * (n - 1))) * s
                }
            }
        }
        return(subgraphEfficiency)
    }
    
    /**
     * Returns the network's subgraphs.
     * @method getSubgraphs
     * @param {object}   adj - Adjascence matrix.
     * @return {object}  Returns the network's subgraphs.
     */
    function getSubgraphs(adj) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        dimJ = dimAdj[1]
        subgraph = core.matrix("", dimI, 1)
        // Find all subgraphs.
        for (i = 1; i < dimI; i = i + 1) {
            // Get all neighbor indexes.
            n = 0
            for (j = 1; j < dimJ; j = j + 1) {
                if (adj[i, j] == 1) {
                    neighbor[n] = j
                    n = n + 1
                }
            }
            if (core.type(neighbor) != "undefined") {
                for (j = 1; j < dimJ; j = j + 1) {
                    if (adj[j, i] == 1) {
                        if (!neighbor.includes(j)) {
                            neighbor[n] = j
                            n = n + 1
                        }
                    }
                }
                // Store this subgraph.
                subgraph[i, 0] = core.replace(core.replace(core.toString(neighbor), "{", ""), "}", "")
                neighbor = null
            }
        }
        return(subgraph)
    }
    
    /**
     * Returns the network's local efficiency.
     * @method getLocalEfficiency
     * @param {object}   subgraphEfficiency - An array containing network subgraphs efficiencies.
     * @return {number}  Returns the network's local efficiency.
     */
    function getLocalEfficiency(subgraphEfficiency) {
        dimSubgraphEfficiency = core.dim(subgraphEfficiency)
        n = dimSubgraphEfficiency[0] - 1
        localEfficiency = (1.0 / n) * matrix.sum(subgraphEfficiency)
        return(localEfficiency)
    }
    
    /**
     * Returns the network vertices labels.
     * @method getLabels
     * @param {object}   adj - Adjascence matrix.
     * @return {number}  Returns the network vertices labels.
     */
    function getLabels(adj) {
        dimAdj = core.dim(adj)
        dimI = dimAdj[0]
        labels = []
        for (i = 1; i < dimI; i = i + 1) {
            labels[i] = adj[i, 0]
        }
        return(labels)
    }
}