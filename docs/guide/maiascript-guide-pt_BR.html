<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"></head><body><h1 id="maiascript-guide">MaiaScript Guide</h1>
<p>MaiaScript é uma linguagem de programação voltada a construção de aplicações adaptáveis e inteligentes, com ênfase na facilidade de aprendizagem e elevada performance. São suportados nativamente, operações com números complexos e matrizes, criação e análise de redes complexas e sociais, redes neurais artificiais, acesso a bancos de dados SQL, programação paralela com threads e GPU, estatística avançada, computação algébrica, incluindo cálculo diferencial e integral e programação de aplicações desktop e web.</p>
<p>Este manual cobre os fundamentos de programação em MaiaScript, apresentando exemplos práticos para os recursos mais comumente usados e orientações gerais sobre o uso desta linguagem.</p>
<p>Para informações detalhadas sobre a gramática da linguagem MaiaScript consulte a descrição em EBNF e os diagramas de sintaxe disponíveis na pasta <code>docs</code> da sua distribuição do compilador MaiaScript.</p>
<h2 id="tipos-de-dados">Tipos de dados</h2>
<p>MaiaScript suporta três tipos de dados nativamente: <code>integer</code>, <code>real</code> e <code>string</code>. Esses tipos são automáticos, não sendo necessário defini-los quando da criação de variáveis e funções comuns. Para uso exclusivamente com funções em <strong>WebAssembly</strong> e <strong>MaiaAssembly</strong> são suportados os tipos <code>integer 32 bits</code>, <code>ì32</code>, <code>integer 64 bits</code>, <code>ì64</code>, <code>real 32 bits</code>, <code>f32</code> e <code>real 64 bits</code>, <code>f64</code>. Funções em <strong>MaiaAssembly</strong> são tratadas no capítulo sobre funções. Funções em <strong>WebAssembly</strong> estão além do escopo deste guia. Para maiores informações consulte o site oficial do projeto: <a href="https://webassembly.org">https://webassembly.org</a>.</p>
<h2 id="saída-de-dados">Saída de dados</h2>
<p>MaiaScript permite a exibição de mensagens na tela do computador, ou na saída padrão, através de várias funções da biblioteca <code>system</code>, dentre elas as mais usadas são <code>print</code>, <code>println</code>, <code>printf</code> e <code>showMessageDialog</code>. O exemplo a seguir ilustra o uso dessas funções:</p>
<pre><code>system.println(&quot;Hello World!&quot;)
system.showMessageDialog(&quot;Hello World!&quot;)
system.printf(&quot;%d, %.3f, %s&quot;, 1, 1.23456, &quot;Hello World!&quot;)
</code></pre>
<h2 id="entrada-de-dados">Entrada de dados</h2>
<p>É possível ler dados digitados pelo usuário através da função <code>showInputDialog</code> da biblioteca <code>system</code>. Esta função exibe uma caixa de diálogo com a mensagem passada como parâmetro e um botão de confirmação, que quando clicado, retorna o valor digitado na caixa de texto apresentada. O exemplo a seguir ilustra o uso desta função:</p>
<pre><code>a = system.showInputDialog(&quot;Type a number:&quot;)
system.println(a)
</code></pre>
<h2 id="variáveis">Variáveis</h2>
<p>Variáveis são contêineres onde armazenamos dados para processamento ou resultados de processamentos. Em MaiaScript variáveis podem armazenar valores de qualquer tipo, não sendo normalmente necessário especificar o tipo de dado que a variável ira armazenar, no momento de sua criação. Contudo, quando da criação de funções em <strong>MaiaAssembly</strong> ou <strong>WebAssembly</strong>, deve-se especificar o tipo de dado que a variável ira armazenar e esta variável só poderá armazenar valores deste tipo de dado por toda a sua existência. São suportados os tipos <code>integer 32 bits</code>, <code>ì32</code>, <code>integer 64 bits</code>, <code>ì64</code>, <code>real 32 bits</code>, <code>f32</code>, <code>real 64 bits</code>, <code>f64</code>. Funções em <strong>MaiaAssembly</strong> são tratadas no capítulo sobre funções. Funções em <strong>WebAssembly</strong> estão além do escopo deste guia. Para maiores informações consulte o site oficial do projeto: <a href="https://webassembly.org">https://webassembly.org</a>. O exemplo a seguir mostra como criar variáveis de diversos tipos:</p>
<pre><code>a = 1
system.println(a)
b = 2.0
system.println(b)
c = &quot;Hello World!&quot;
system.println(c)
d = [1, 2.0]
system.println(d)
e = []
system.println(e)

// Vetores semelhantes ao JavaScript.
f = [[1, 2],[3, 4]]
system.println(f)

// Matrizes semelhantes ao Matlab.
g = [5, 6; 7, 8]
system.println(g)

// Objetos semelhantes ao JavaScript
h = {a: 1, b: 2.0, &quot;c&quot;: &quot;Hello World!&quot;}
system.println(JSON.stringify(h))
i = {}
system.println(JSON.stringify(i))
</code></pre>
<h2 id="operadores">Operadores</h2>
<p>MaiaScript suporta operadores matemáticos, relacionais, lógicos, de deslocamento de bits, de operação e atribuição e o operador condicional ternário. A seguir apresentamos em notação EBNF todos os operadores suportados pela linguagem. A ordem de precedência é de cima para baixo.</p>
<pre><code>Operation                ::= VariableAssignment
VariableAssignment       ::= ConditionalExpression ((&#39;=&#39; | &#39;*=&#39; | &#39;/=&#39; | &#39;%=&#39; | &#39;+=&#39; | &#39;-=&#39; | &#39;&lt;&lt;=&#39; | &#39;&gt;&gt;=&#39; | &#39;&amp;=&#39; | &#39;^=&#39; | &#39;|=&#39; | &#39;?=&#39; | &#39;:=&#39;) ConditionalExpression)*
ConditionalExpression    ::= LogicalORExpression (&#39;?&#39; VariableAssignment &#39;:&#39; VariableAssignment)?
LogicalORExpression      ::= LogicalANDExpression (&#39;||&#39; LogicalANDExpression)*
LogicalANDExpression     ::= BitwiseORExpression (&#39;&amp;&amp;&#39; BitwiseORExpression)*
BitwiseORExpression      ::= BitwiseXORExpression (&#39;|&#39; BitwiseXORExpression)*
BitwiseXORExpression     ::= BitwiseANDExpression (&#39;^&#39; BitwiseANDExpression)*
BitwiseANDExpression     ::= EqualityExpression (&#39;&amp;&#39; EqualityExpression)*
EqualityExpression       ::= RelationalExpression ((&#39;==&#39; | &#39;!=&#39;) RelationalExpression)*
RelationalExpression     ::= ShiftExpression ((&#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&lt;=&#39; | &#39;&gt;=&#39;) ShiftExpression)*
ShiftExpression          ::= AdditiveExpression ((&#39;&lt;&lt;&#39; | &#39;&gt;&gt;&#39;) AdditiveExpression)*
AdditiveExpression       ::= PowerExpression ((&#39;+&#39; | &#39;-&#39;) PowerExpression)*
PowerExpression          ::= MultiplicativeExpression (&#39;**&#39; MultiplicativeExpression)*
MultiplicativeExpression ::= UnaryExpression ((&#39;*&#39; | &#39;/&#39; | &#39;%&#39;) UnaryExpression)*
UnaryExpression          ::= Primary &#39;++&#39;
                           | Primary &#39;--&#39;
                           | &#39;++&#39; Primary
                           | &#39;--&#39; Primary
                           | &#39;+&#39; Primary
                           | &#39;-&#39; Primary
                           | &#39;~&#39; Primary
                           | &#39;!&#39; Primary
                           | Primary

Primary                  ::= Type? Member
                           | Value
                           | ParenthesizedExpression
</code></pre>
<p>Nas próximas sessões abordaremos cada um desses operadores.</p>
<h3 id="operadores-matemáticos">Operadores matemáticos</h3>
<p>MaiaScript suporta os operadores matemáticos <strong>soma</strong>, <code>+</code>, <strong>subtração</strong>, <code>-</code>, <strong>potenciação</strong>, <code>**</code>, <strong>multiplicação</strong>, <code>*</code>, <strong>divisão</strong>, <code>/</code> e <strong>resto da divisão</strong>, <code>%</code>. Os exemplos a seguir mostram como utilizar esses operadores:</p>
<pre><code>a = 1
b = 2

c = a + b
system.println(c)

c = a - b
system.println(c)

c = a * b
system.println(c)

c = a / b
system.println(c)

c = a % b
system.println(c)

// Operador de potência semelhante ao Python.
c = a ** b
system.println(c)

// Operadores de incremento e decremento semelhantes ao C.
c = a++
system.println(c)
c = b--
system.println(c)
c = ++a
system.println(c)
c = --b
system.println(c)
</code></pre>
<h3 id="operadores-relacionais">Operadores relacionais</h3>
<p>MaiaScript suporta os operadores relacionais <strong>igual</strong>, <code>==</code>, <strong>diferente</strong>, <code>!=</code>, <strong>menor</strong>, <code>&lt;</code>, <strong>menor ou igual</strong>, <code>&lt;=</code>, <strong>maior</strong>, <code>&gt;</code> e <strong>maior ou igual</strong>, <code>&gt;=</code>. Os exemplos a seguir mostram como utilizar esses operadores:</p>
<pre><code>a = 1
b = 2

c = a == b
system.println(c)
c = a != b
system.println(c)
c = a &lt; b
system.println(c)
c = a &lt;= b
system.println(c)
c = a &gt; b
system.println(c)
c = a &gt;= b
system.println(c)
</code></pre>
<h3 id="operadores-lógicos">Operadores lógicos</h3>
<p>MaiaScript suporta os operadores lógicos <strong>e</strong>, <code>&amp;&amp;</code>, <strong>ou</strong>, <code>||</code>, <strong>e bit a bit</strong>, <code>&amp;</code>, <strong>ou exclusivo bit a bit</strong>, <code>^</code> e <strong>ou bit a bit</strong>, <code>|</code>. Os exemplos a seguir mostram como utilizar esses operadores:</p>
<pre><code>a = 1
b = 0

c = a &amp;&amp; b
system.println(c)
c = a || b
system.println(c)
c = a &amp; b
system.println(c)
c = a | b
system.println(c)
c = a ^ b
system.println(c)
</code></pre>
<h3 id="operadores-de-deslocamento-de-bits">Operadores de deslocamento de bits</h3>
<p>MaiaScript suporta os operadores de <strong>deslocamento a esquerda</strong>, <code>&lt;&lt;</code>, e <strong>deslocamento a direita</strong>, <code>&gt;&gt;</code>. Os exemplos a seguir mostram como utilizar esses operadores:</p>
<pre><code>a = 3

c = a &lt;&lt; 2
system.println(c)
c = a &gt;&gt; 2
system.println(c)
</code></pre>
<h3 id="operadores-de-operação-e-atribuição">Operadores de operação e atribuição</h3>
<p>MaiaScript suporta os seguintes operadores especiais de operação seguida de atribuição: <code>*=</code> , <code>/=</code> , <code>%=</code> , <code>+=</code> , <code>-=</code> , <code>&lt;&lt;=</code> , <code>&gt;&gt;=</code> , <code>&amp;=</code> , <code>^=</code> , <code>|=</code>. A seguir são apresentados exemplos dos usos mais comuns desses operadores:</p>
<pre><code>c = a += b
system.println(c)
c = a -= b
system.println(c)
</code></pre>
<h3 id="operador-condicional-ternário">Operador condicional (ternário)</h3>
<p>A linguagem MaiaScript oferece um <strong>operador condicional ternário</strong>. Este operador recebe três operandos: uma <code>expressão condicional</code>, uma <code>expressão que será retornada caso a condição seja avaliada como verdadeira</code> e uma <code>expressão que será retornada caso a condição seja avaliada como falsa</code>. No exemplo a seguir, como a variável <code>a</code> contém o valor <code>1</code> a condição <code>a == 1</code> será avaliada como <code>verdadeira</code> e a expressão <code>&quot;Hello&quot;</code> será retornada.</p>
<pre><code>a = 1

c = a == 1 ? &quot;Hello&quot; : &quot;World&quot;
system.println(c)
</code></pre>
<h3 id="números-complexos">Números complexos</h3>
<p>MaiaScript suporta <strong>números complexos</strong> nativamente para os operadores <code>+</code>, <code>-</code>, <code>**</code>, <code>*</code> e <code>\</code> e para as funções matemáticas <code>abs</code>, <code>arg</code>, <code>cos</code>, <code>cosh</code>, <code>exp</code>, <code>log</code>, <code>sin</code>, <code>sinh</code>, <code>sqrt</code>, <code>tan</code> e <code>tanh</code>. Também estão disponíveis diversas funções especializadas na biblioteca <code>core</code>. Para conhecer todas as funções MaiaScript com suporte a números complexos, consulte a documentação das bibliotecas na pasta <code>docs</code> em sua distribuição do compilador MaiaScript.</p>
<p>A seguir é apresentada em notação EBNF a sintaxe de números complexos em MaiaScript:</p>
<pre><code>Complex                  ::= Real? Imaginary
Real                     ::= &#39;-&#39;? Digit+ &#39;.&#39; Digit+ ((&#39;e&#39; | &#39;E&#39; | &#39;p&#39; | &#39;P&#39;) (&#39;+&#39; | &#39;-&#39;)? Digit+)?
Imaginary                ::= ((&#39;+&#39; | &#39;-&#39;)? Real &#39;*&#39; &#39;i&#39;)
</code></pre>
<p>O exemplo a seguir ilustra a operação de soma com dois números complexos:</p>
<pre><code>e = 1.0+2.0*i
f = 3.0+4.0*i
g = e + f
system.println(g)
</code></pre>
<h3 id="matrizes">Matrizes</h3>
<p>MaiaScript suporta matrizes nativamente para os operadores <code>+</code>, <code>-</code>, <code>**</code>, e <code>*</code> e oferece a biblioteca <code>matrix</code> para algebra linear. Também estão disponíveis diversas funções especializadas na biblioteca <code>core</code>. Para conhecer todas as funções MaiaScript com suporte a matrizes, consulte a documentação das bibliotecas na pasta <code>docs</code> em sua distribuição do compilador MaiaScript.</p>
<p>A seguir é apresentada em notação EBNF a sintaxe <strong>vetores associativos</strong> e <strong>matrizes</strong> em MaiaScript:</p>
<pre><code>Array                    ::= &#39;{&#39; Element? (&#39;,&#39; Element)* &#39;}&#39;
Matrix                   ::= &#39;[&#39; Row? (&#39;;&#39; Row)* &#39;]&#39;

Element                  ::= (Key &#39;:&#39;)? Expression
Key                      ::= Identifier
                           | String

Row                      ::= Column (&#39;,&#39; Column)*
Column                   ::= Expression
</code></pre>
<p>Em MaiaScript pode-se usar tanto a notação de matrizes do <strong>Matlab</strong> quanto do <strong>JavaScript</strong>. Na notação Matlab as colunas são separadas por <code>vírgulas</code>, <code>,</code>, e as linhas por <code>pontos e vírgulas</code>, <code>;</code>. Na notação JavaScript cada linha deve ser indicada entre colchetes <code>[]</code> e as linhas separadas por <code>vírgulas</code>, <code>,</code>. O exemplo a seguir apresenta exemplos de operações com matrizes usando as duas notações:</p>
<pre><code>a = [1, 2; 3, 4]
b = [[5, 6], [7, 8]]

c = a + b
system.println(c)

c = a - b
system.println(c)

c = a ** 2
system.println(c)

c = a * b
system.println(c)
</code></pre>
<h2 id="estruturas-de-decisão">Estruturas de decisão</h2>
<p>MaiaScript oferece duas estruturas para controle de fluxo de execução: <code>if... else...</code> e <code>switch</code>. Ambas as estruturas estão disponíveis tanto no MaiaScript quanto no MaiaAssembly. Nas próximas sessões serão apresentadas essas declarações, assim como exemplos de suas utilizações.</p>
<h3 id="declaração-se-então">Declaração Se... Então...</h3>
<p>A declaração <code>if... else...</code> permite decidir, mediante a avaliação de uma <code>condição</code> pela execução de uma sessão de <code>código de programa</code> ou não. A <code>expressão condicional</code> deve ser apresentada imediatamente após a palavra <code>if</code> e entre <code>parênteses</code>. Caso essa expressão seja avaliada como <code>verdadeira</code> a <code>expressão</code> ou <code>bloco de comandos</code> imediatamente após os <code>parênteses</code> será executada, caso contrário a <code>expressão</code> ou <code>bloco de comandos</code> imediatamente após a palavra <code>else</code> será executada. A cláusula <code>else</code> é opcional.</p>
<p>A seguir é apresentada a sintaxe da declaração <code>if... else...</code> em notação EBNF:</p>
<pre><code>If                       ::= &#39;if&#39; &#39;(&#39; Expression &#39;)&#39; Expression Else?
Else                     ::= &#39;else&#39; Expression
</code></pre>
<p>O exemplo a seguir ilustra o uso da declaração <code>if... else...</code>:</p>
<pre><code>a = 1
b = 2

// Declaração if semelhante ao C.
if (a &lt; b) {
    system.println(&quot;a = &quot; + a)
    system.println(&quot;b = &quot; + b)
    system.println(&quot;a &lt; b&quot;)
    if (a == 1)
        system.println(&quot;a == 1&quot;)
    else
        system.println(&quot;a != 1&quot;)
} else if (a &gt; b) {
    system.println(&quot;a = &quot; + a)
    system.println(&quot;b = &quot; + b)
    system.println(&quot;a &gt; b&quot;)
} else {
    system.println(&quot;a = &quot; + a)
    system.println(&quot;b = &quot; + b)
    system.println(&quot;a == b&quot;)
}
</code></pre>
<h3 id="declaração-selecione-caso">Declaração Selecione... Caso...</h3>
<p>A declaração <code>switch... case... default...</code> permite decidir, mediante a comparação de uma <code>expressão</code> com diversos <code>casos</code> fornecidos, pela execução de uma sessão de <code>código de programa</code> ou não. A <code>expressão condicional</code> deve ser apresentada imediatamente após a palavra <code>switch</code> e entre <code>parênteses</code>. Essa <code>expressão</code> será comparada com cada <code>caso</code> fornecido e caso seja encontrada uma <strong>equivalência</strong> a <code>expressão</code> ou <code>bloco de comandos</code> imediatamente após os <code>dois pontos</code> do <code>caso</code> será executada. Caso nenhum dos casos corresponda à <code>expressão</code> dada, a <code>expressão</code> ou <code>bloco de comandos</code> imediatamente após os <code>dois pontos</code> do caso <code>default</code> será executada. A cláusula <code>default</code> é opcional.</p>
<p>A seguir é apresentada a sintaxe da declaração <code>switch... case... default...</code> em notação EBNF:</p>
<pre><code>Switch                   ::= &#39;switch&#39; &#39;(&#39; Expression &#39;)&#39; &#39;{&#39; Case+ Default? &#39;}&#39;
Case                     ::= &#39;case&#39; Expression &#39;:&#39; Expression*
Default                  ::= &#39;default&#39; &#39;:&#39; Expression*
</code></pre>
<p>O exemplo a seguir ilustra o uso da declaração <code>switch... case... default...</code>:</p>
<pre><code>a = 1

// Declaração switch semelhante ao C.
switch (a) {
    case 0:
    case 1:
        system.println(&quot;a == 0 || a == 1 || a == 2&quot;)
    case 2:
        system.println(&quot;a == 2&quot;)
        break
    default:
        system.println(&quot;a = &quot; + a)
        system.println(&quot;a != 1 &amp;&amp; a != 2&quot;)
}
</code></pre>
<h2 id="estruturas-de-repetição">Estruturas de repetição</h2>
<p>Estruturas de repetição permitem executar uma sessão de programa um número de vezes ou até que uma condição seja satisfeita. MaiaScript oferece quatro estruturas de repetição: <code>do... while</code>, <code>while...</code>, <code>for</code> e <code>foreach</code>. Todas essas estruturas estão disponíveis tanto no MaiaScript quanto no MaiaAssembly. Nas próximas sessões serão apresentadas essas declarações, assim como exemplos de suas utilizações.</p>
<h3 id="declaração-faça">Declaração Faça...</h3>
<p>A declaração <code>do... while...</code> executa uma <code>expressão</code> ou <code>bloco de comandos</code> <code>enquanto</code> uma dada <code>condição</code> for avaliada como <code>verdadeira</code>. A diferença desta declaração e da declaração <code>while...</code> é que esta declaração <strong>executa pelo menos uma vez</strong> a sessão de código, mesmo que a <code>condição</code> já seja <code>falsa</code> quando o fluxo de execução do programa chegar a ela, enquanto a declaração <code>while...</code> <strong>não executará nenhuma vez</strong> caso a <code>condição</code> já seja <code>falsa</code> quando o fluxo de execução do programa chegar a ela. Caso se deseje interromper a execução do <strong>laço</strong> antes que a <code>condição</code> se torne <code>falsa</code>, pode-se utilizar a declaração <code>break</code>. Caso se deseje interromper a execução da iteração atual do <strong>laço</strong> antes que o <strong>bloco de comandos</strong> tenha sido completamente executado e saltar para a próxima iteração, pode-se utilizar a declaração <code>continue</code>.</p>
<p>A seguir é apresentada a sintaxe da declaração <code>do... while...</code> em notação EBNF:</p>
<pre><code>Do                       ::= &#39;do&#39; Expression &#39;while&#39; &#39;(&#39; Expression &#39;)&#39;
Break                    ::= &#39;break&#39;
Continue                 ::= &#39;continue&#39;
</code></pre>
<p>O exemplo a seguir ilustra o uso da declaração <code>do... while...</code>:</p>
<pre><code>a = 0

do {
    system.println(a)
    a++
} while (a &lt; 10);
</code></pre>
<h3 id="declaração-enquanto">Declaração Enquanto...</h3>
<p>A declaração <code>while...</code> executa uma <code>expressão</code> ou <code>bloco de comandos</code> <code>enquanto</code> uma dada <code>condição</code> for avaliada como <code>verdadeira</code>. A diferença desta declaração e da declaração <code>do... while...</code> é que aquela declaração <strong>executa pelo menos uma vez</strong> a sessão de código, mesmo que a <code>condição</code> já seja <code>falsa</code> quando o fluxo de execução do programa chegar a ela, enquanto a declaração <code>while...</code> <strong>não executará nenhuma vez</strong> caso a <code>condição</code> já seja <code>falsa</code> quando o fluxo de execução do programa chegar a ela. Caso se deseje interromper a execução do <strong>laço</strong> antes que a <code>condição</code> se torne <code>falsa</code>, pode-se utilizar a declaração <code>break</code>. Caso se deseje interromper a execução da iteração atual do <strong>laço</strong> antes que o <strong>bloco de comandos</strong> tenha sido completamente executado e saltar para a próxima iteração, pode-se utilizar a declaração <code>continue</code>.</p>
<p>A seguir é apresentada a sintaxe da declaração <code>while...</code> em notação EBNF:</p>
<pre><code>While                    ::= &#39;while&#39; &#39;(&#39; Expression &#39;)&#39; Expression
</code></pre>
<p>O exemplo a seguir ilustra o uso da declaração <code>while...</code>:</p>
<pre><code>a = 0

while (a &lt; 10) {
    if (a % 2 == 0) {
        continue
    }
    if (a &gt;= 5) {
        system.println(&quot;Break the loop.&quot;)
        break
    }
    system.println(a)
    a++
}
</code></pre>
<h3 id="declaração-para">Declaração Para...</h3>
<p>A declaração <code>for...</code> executa uma <code>expressão</code> ou <code>bloco de comandos</code> <code>enquanto</code> uma dada <code>condição</code> for avaliada como <code>verdadeira</code>. A diferença desta declaração e da declaração <code>while...</code> é que aquela declaração requer um controle interno da <code>condição</code> de execução para que em algum momento a <code>condição</code> se torne falsa e a execução do código seja interrompida. Esta declaração permite passar três argumentos: uma <code>expressão que será executado antes da primeira interação</code>, uma <code>expressão condicional</code> e uma <code>expressão que será avaliada ao final de cada iteração</code>. Pode-se usar o <code>primeiro parâmetro</code> para <strong>inicializar uma variável de controle</strong>, e o <code>último parâmetro</code> para <strong>modificá-lo</strong>. Caso se deseje interromper a execução do <strong>laço</strong> antes que a <code>condição</code> se torne <code>falsa</code>, pode-se utilizar a declaração <code>break</code>. Caso se deseje interromper a execução da iteração atual do <strong>laço</strong> antes que o <strong>bloco de comandos</strong> tenha sido completamente executado e saltar para a próxima iteração, pode-se utilizar a declaração <code>continue</code>.</p>
<p>A seguir é apresentada a sintaxe da declaração <code>for...</code> em notação EBNF:</p>
<pre><code>For                      ::= &#39;for&#39; &#39;(&#39; Expression &#39;;&#39; Expression &#39;;&#39; Expression &#39;)&#39; Expression
</code></pre>
<p>O exemplo a seguir ilustra o uso da declaração <code>for...</code>:</p>
<pre><code>b = [1, 2, 3]

for (a = 0; a &lt; 10; ++a) {
    system.println(a)
}

for (i = 0; i &lt; b.length; i++) {
    system.println(b[i])
}
</code></pre>
<h3 id="declaração-para-cada">Declaração Para cada...</h3>
<p>A declaração <code>foreach...</code> executa uma <code>expressão</code> ou <code>bloco de comandos</code> <code>para cada</code> elemento de um <code>vetor associativo</code> ou <code>objeto</code>. Esta declaração recebe três parâmetros: um <code>vetor associativo</code> ou <code>objeto</code>, uma <code>variável para conter a chave do vetor</code> ou <code>nome da propriedade do objeto</code> e uma <code>variável para conter o valor do elemento do vetor</code> ou objeto. Caso se deseje interromper a execução do <strong>laço</strong> antes que a <code>condição</code> se torne <code>falsa</code>, pode-se utilizar a declaração <code>break</code>. Caso se deseje interromper a execução da iteração atual do <strong>laço</strong> antes que o <strong>bloco de comandos</strong> tenha sido completamente executado e saltar para a próxima iteração, pode-se utilizar a declaração <code>continue</code>.</p>
<p>A seguir é apresentada a sintaxe da declaração <code>foreach...</code> em notação EBNF:</p>
<pre><code>ForEach                  ::= &#39;foreach&#39; &#39;(&#39; Expression &#39;;&#39; Expression &#39;;&#39; Expression &#39;)&#39; Expression
</code></pre>
<p>O exemplo a seguir ilustra o uso da declaração <code>foreach...</code>:</p>
<pre><code>c = {a: 1, b: 2}

// Declaração foreach semelhante ao Tcl.
foreach(c; key; value) {
    system.println(key + &quot;: &quot; + value)
}
</code></pre>
<h2 id="funções">Funções</h2>
<p>Funções e procedimentos são sub-rotinas de programa que podem ser executadas invocando-se seus nomes. MaiaScript suporta diversos tipos de funções. Nas próximas sessões discutiremos cada um deles.</p>
<p>A seguir é apresentada a sintaxe para os diversos tipos de <code>funções</code> MaiaScript em notação EBNF:</p>
<pre><code>FunctionDeclaration      ::= Identifier (&#39;.&#39; Identifier)* &#39;(&#39; Arguments? &#39;)&#39; &#39;=&#39; Expression
                           | Identifier (&#39;.&#39; Identifier)* &#39;(&#39; Arguments? &#39;)&#39; &#39;?=&#39; Block
                           | Identifier (&#39;.&#39; Identifier)* &#39;(&#39; Arguments? &#39;)&#39; &#39;#=&#39; Block
                           | Identifier (&#39;.&#39; Identifier)* &#39;(&#39; Arguments? &#39;)&#39; &#39;:=&#39; Block
                           | Type? Identifier (&#39;.&#39; Identifier)* &#39;(&#39; Arguments? &#39;)&#39; Block
                           | Type? Identifier (&#39;.&#39; Identifier)* &#39;(&#39; Arguments? &#39;)&#39; Script
Return                   ::= &#39;return&#39; Expression
</code></pre>
<h3 id="declaração-de-uma-função">Declaração de uma função</h3>
<p>Declaramos uma <code>função</code> escrevendo seu <code>nome</code>, seguido de <code>parênteses</code>, que podem ou não conter <code>argumentos</code> separados por <code>vírgulas</code>, <code>,</code>, e um <code>bloco de comandos</code> entre <code>chaves</code>, <code>{}</code>. Funções em MaiaScript podem ou não ter <code>tipos de retornos</code> declarados e utilizar ou não <code>operadores especiais de atribuição</code>, <code>=</code>, <code>?=</code>, <code>#=</code>, <code>:=</code>, em sua declaração.</p>
<p>Caso um <code>tipo de retorno</code> seja indicado na declaração da função, ela será interpretada como sendo uma função em <strong>MaiaAssembly</strong> ou em <strong>WebAssembly</strong>. Nos dois casos deve-se especificar os <code>tipos dos valores</code> dos argumentos da função caso ela possua <code>argumentos</code>. Se as <code>chaves</code>, <code>/{ /}</code> dos <code>blocos de comandos</code> forem precedidas do caractere <code>/</code> a função será interpretada como sendo em <strong>WebAssembly</strong>, caso contrário será considerada como sendo em <strong>MaiaAssembly</strong>. Funções MaiaScript podem ser <strong>recursivas</strong>, ou seja chamar a si mesmas para executar tarefas complexas. O exemplo a seguir ilustra a função <code>factorial</code> implementada usando um algoritmo recursivo:</p>
<pre><code>// Uma função recursiva.
factorial(n) {
    if (n == 0 || n == 1) {
        return 1
    }
    return n * factorial(n - 1)
}

system.println(factorial(5))
</code></pre>
<h3 id="funções-em-linha">Funções em linha</h3>
<p>Para funções mais simples, que podem ser implementadas em apenas uma linha, pode-se usar a forma simplificada de declaração de funções. Esta forma permite escrever uma função da forma como se costuma fazer na matemática, utilizando-se o operador <code>atribuição</code>, <code>=</code>, e omitindo-se as chaves do <code>bloco de comandos</code>. O exemplo a seguir mostra a declaração de uma função do segundo grau:</p>
<pre><code>// Uma função em linha.
f(x) = 2 * x ** 2 + x - 1

system.println(f(2))
</code></pre>
<h3 id="funções-assíncronas">Funções assíncronas</h3>
<p>Funções pode ser <strong>executadas assincronamente</strong>. Para tanto deve-se declarar a função utilizando-se o <code>operador de execução assíncrona</code>, <code>?=</code>. Para esperar a <strong>função assíncrona</strong> terminar sua execução, bloqueado o <strong>fluxo de execução</strong> do resto do programa, deve-se <code>atribuir</code> a função a uma <code>variável</code> utilizando-se o <code>operador de execução assíncrona</code>, <code>?=</code>.</p>
<pre><code>// Uma função assíncrona.
f(x) ?= {
    return x
}

// Uma chamada de função assíncrona.
a ?= f(2)
</code></pre>
<h3 id="funções-paralelas">Funções paralelas</h3>
<p>MaiaScript permite criar funções paralelas usando <strong>threads</strong> ou <strong>núcleos de GPU</strong>. Nos dois casos as funções precisam ser do tipo <code>kernel</code>. Funções <code>kernel</code> devem ser criadas usando-se o <code>operador de declaração de função kernel</code>, <code>#=</code>. Uma função <code>kernel</code> é compilada de forma diferente das demais funções. Elas não suportam operações com números complexos nem com matrizes. Somente os tipos de dados e recursos básicos do JavaScript são suportados. O exemplo a seguir mostra como criar uma <strong>thread</strong> em MaiaScript. Para maiores detalhes consulte a documentação da biblioteca <code>task</code> disponível na pasta <code>docs</code> da sua distribuição do compilador MaiaScript.</p>
<pre><code>// Uma função paralela.
task1() #= {
    i = 0
    timedCount() #= {
        i++
        postMessage(i)
        if (i &lt; 10) {
            setTimeout(timedCount(), 500)
        }
    }
    timedCount()
}

onMessage1(m) {
    system.log(&quot;Task 1: &quot; + m.data)
    if (m.data &gt;= 5) {
        t1.terminate()
    }
}

try {
    t1 = task.new(task1)
    t1.onmessage = onMessage1
} catch (e) {
    system.log(e.message)
}
</code></pre>
<h3 id="funções-em-maiaassembly">Funções em MaiaAssembly</h3>
<p><strong>MaiaAssembly</strong> é uma linguagem de programação otimizada para compilação para <strong>WebAssembly</strong>. Ela permite criar algoritmos tão rápidos quanto programas escritos em linguagem C, embutidos em programas de alto nível em MaiaScript. Funções em <strong>MaiaAssembly</strong> são tipadas, o que significa que é preciso declarar os tipos das funções e variáveis no momento de suas criações. Os tipos suportados em <strong>MaiaAssembly</strong> são <code>integer 32 bits</code>, <code>ì32</code>, <code>integer 64 bits</code>, <code>ì64</code>, <code>real 32 bits</code>, <code>f32</code> e <code>real 64 bits</code>, <code>f64</code>. Todos as estruturas de decisão e de repetição do <strong>MaiaScript</strong> são suportados em <strong>MaiaAssembly</strong>. Além disso são suportados <code>vetores</code> de dimensões arbitrárias dos <code>tipos</code> de dados suportados. Não é possível passar objetos ou mesmo vetores como argumentos de funções <strong>MaiaAssembly</strong>, mas é possível importá-los. Para tanto utiliza-se a declaração <code>import</code>. Ela permite importar propriedades de objetos para dentro da função e utilizá-las como se fossem variáveis locais. Em <strong>MaiaAssembly</strong> é possível criar <strong>variáveis globais</strong> usando-se a declaração <code>global</code>. Variáveis globais são acessáceis de qualquer parte do programa. O exemplo a seguir mostra como criar uma função para somar dois valores passados para ela como argumentos. A função também cria uma <code>variável local</code> para armazenar o resultado da soma. Variáveis locais devem ser declaradas no cabeçalho da função e devem aparecer após os argumentos da função.</p>
<pre><code>// Uma função em MaiaAssembly.
i32 f4(i32 a, i32 b, local i32 c) {
    c = a + b;
    return c;
}

// Chamando uma função em MaiaAssembly.
c = f(1, 2)
</code></pre>
<h3 id="funções-em-javascript">Funções em JavaScript</h3>
<p>Funções em <strong>JavaScript</strong> podem ser declaradas precedendo as <code>chaves</code>, <code>/{ /}</code> dos <code>blocos de comandos</code> com o caractere <code>/</code>. <strong>Funções em JavaScript não são compiladas</strong>, sendo inseridas no código produzido pelo compilador da forma como tiverem sido escritas. O exemplo a seguir mostra como definir uma função em <strong>JavaScript</strong>:</p>
<pre><code>// Uma função em JavaScript.
f(x) /{
    y = x + 1;
    return y;
}/

// Chamando uma função em JavaScript.
c = f(2)
</code></pre>
<h3 id="funções-em-webassembly">Funções em WebAssembly</h3>
<p>Funções em <strong>WebAssembly</strong> são montadas pelo assembler e inseridas em forma binária no código resultante da compilação. Elas são tipadas, o que significa que é preciso declarar os tipos das funções e variáveis no momento de suas criações. Os tipos suportados em <strong>WebAssembly</strong> são <code>integer 32 bits</code>, <code>ì32</code>, <code>integer 64 bits</code>, <code>ì64</code>, <code>real 32 bits</code>, <code>f32</code> e <code>real 64 bits</code>, <code>f64</code>. <code>Variáveis locais</code> devem ser declaradas no cabeçalho da função e devem aparecer após os argumentos da função. O exemplo a seguir mostra como criar uma função para somar dois valores passados para ela como argumentos:</p>
<pre><code>// Uma função em WebAssembly.
i32 f(i32 a, i32 b) /{
    (i32.add
      (local.get $a)
      (local.get $b)
    )
}/

// Chamando uma função em WebAssembly.
f = f(1, 2)
</code></pre>
<h2 id="criando-namespaces-e-objetos">Criando namespaces e objetos</h2>
<p><strong>Namespaces</strong> são uma forma de organizar funções e variáveis para constituir bibliotecas. O uso de <code>namespaces</code> não só torna mais organizado e reusável o código, mas também tornam o acesso aos recursos das bibliotecas mais eficiente. Todo <code>namespace</code> é um <code>objeto</code>, mas <code>namespaces</code> não são <code>construtores de objetos</code>. Para criar <code>objetos</code> devemos criar <code>construtores</code> para eles. Nas próximas sessões veremos como criar <code>namespaces</code> e <code>construtores de objetos</code>.</p>
<h3 id="criando-namespaces">Criando Namespaces</h3>
<p>Criamos um <code>namespace</code> definindo um <code>nome</code> para ele e um <code>bloco de código</code> contendo variáveis e funções.</p>
<p>A seguir é apresentada a sintaxe para criação de <code>namespaces</code> em notação EBNF:</p>
<pre><code>NamespaceDeclaration     ::= Identifier (&#39;.&#39; Identifier)* Block
</code></pre>
<p>O exemplo a seguir ilustra como criar um <code>namespace</code> contendo uma <code>variável</code>, <code>propriedade</code> e uma <code>função</code>, <code>método</code>:</p>
<pre><code>// Criando um namespace (um objeto)
a {
    b = 1
    f(n) {
        if (n == 0 || n == 1) {
            return 1
        }
        return n * this.f(n - 1)
    }
}

system.println(a.b)
system.println(a.f(5))
</code></pre>
<h3 id="construtores-de-objetos">Construtores de Objetos</h3>
<p><strong>Construtores de objetos</strong> permitem criar <code>instancias de classes</code> definidas por eles. <code>Classes</code> são <strong>moldes</strong> para <code>objetos</code>. Elas definem suas <code>propriedades</code>, características mutáveis em tempo de execução, e seus <code>métodos</code>, funcionalidades dos objetos. Para criar um <code>construtor de objetos</code> definimos uma função utilizando o <code>operador para criação de objetos</code>, <code>:=</code>. Para <strong>instanciar</strong> um <code>objeto</code> atribuímos a uma variável o valor de retorno do <code>construtor de objetos</code>, utilizando o <code>operador para criação de objetos</code>, <code>:=</code>. O exemplo a seguir cria uma <code>objeto</code> que possui uma propriedade <code>y</code> e atribui a essa variável o valor passado para o construtor no momento de sua criação:</p>
<pre><code>// Um construtor de objeto.
A(x) := {
    y = x
}

c := A(2)

system.println(c.y);
</code></pre>
<h2 id="redes-complexas-e-sociais">Redes complexas e sociais</h2>
<p>MaiaScript fornece diversas funções para criação e <strong>análise de redes complexas e sociais</strong>. Esses recursos estão disponíveis nas bibliotecas <code>cna</code>e <code>snet</code>. Os exemplos a seguir mostram as aplicações mais comuns para as funções dessas bibliotecas. Para uma referência completa consulte a documentação disponível na pasta <code>docs</code> de sua distribuição do compilador MaiaScript.</p>
<pre><code>// Cria um arquivo de rede no formato Pajek.
fileContents = &quot;&quot;
fileContents = fileContents + &quot;*Vertices 10&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;1 \&quot;v1\&quot; -13.53320569881955 15.024369378567805 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;2 \&quot;v2\&quot; 138.57890381783866 -149.73844730901712 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;3 \&quot;v3\&quot; -195.0525404708813 294.7061191626409 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;4 \&quot;v4\&quot; -4.710077309561689 -119.03537285786881 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;5 \&quot;v5\&quot; 276.72724773173434 -241.1655959044472 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;6 \&quot;v6\&quot; 218.72444256014836 -294.7061191626409 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;7 \&quot;v7\&quot; 119.53996984903722 -4.504246484231039 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;8 \&quot;v8\&quot; -276.72724773173434 219.58638008091668 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;9 \&quot;v9\&quot; -80.8765683805954 206.98274428233245 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;10 \&quot;v10\&quot; -198.91296298859544 98.42821322326704 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;*Arcs&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;1 2 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;1 4 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;1 7 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;1 9 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;1 10 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;2 1 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;2 4 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;2 5 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;2 6 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;2 7 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;3 8 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;3 9 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;4 1 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;4 2 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;5 2 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;5 6 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;6 2 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;6 5 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;7 1 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;7 2 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;8 3 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;8 10 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;9 1 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;9 3 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;10 1 1&quot; + &quot;\r\n&quot;
fileContents = fileContents + &quot;10 8 1&quot; + &quot;\r\n&quot;

// Objeto para conter as propriedades da rede.
property = {
    &quot;adj&quot;: [],
    &quot;n&quot;: 0,
    &quot;m&quot;: 0,
    &quot;directed&quot;: false,
    &quot;density&quot;: 0,
    &quot;networkLabel&quot;: [],
    &quot;networkDegree&quot;: [],
    &quot;networkAverageDegree&quot;: 0,
    &quot;networkDegreeDistribution&quot;: [],
    &quot;networkDensity&quot;: 0,
    &quot;networkClustering&quot;: [],
    &quot;networkAverageClustering&quot;: 0,
    &quot;networkShortestPath&quot;: [],
    &quot;networkAverageShortestPath&quot;: 0,
    &quot;networkDiameter&quot;: 0,
    &quot;networkCentrality&quot;: [],
    &quot;networkVertexEfficiency&quot;: [],
    &quot;networkGlobalEfficiency&quot;: 0
}

// Converte o arquivo em uma matriz de adjacência.
property.adj = cna.parsePajekFile(fileContents, property)

// Calcula a densidade da rede.
property.networkDensity = cna.getDensity(property.adj, property.directed)

// Calcula os graus dos vértices e o grau médio da rede.
property.networkDegree = cna.getDegrees(property.adj, property.directed)
property.networkAverageDegree = cna.getAverageDegree(property.networkDegree)

// Calcula os coeficientes de aglomeração dos vértices e o coeficiente de aglomeração médio da rede.
property.networkClustering = cna.getClustering(property.adj, property.directed)
property.networkAverageClustering = cna.getAverageClustering(property.networkClustering)

// Calcula os caminhos mínimos entre os vértices e o caminho mínimo médio da rede.
property.networkShortestPath = cna.getShortestPath(property.adj)
property.networkAverageShortestPath = cna.getAverageShortestPath(property.networkShortestPath)

// Calcula o diâmetro da rede.
property.networkDiameter = cna.getDiameter(property.networkShortestPath)

// Calcula a eficiência global da rede.
property.networkGlobalEfficiency = cna.getGlobalEfficiency(property.networkVertexEfficiency)
</code></pre>
<h2 id="redes-neurais-artificiais">Redes neurais artificiais</h2>
<p>MaiaScript fornece funções para criação e treinar <strong>redes neurais artificiais</strong> de diversas topologias. Esses recursos estão disponíveis na biblioteca <code>ann</code>. Os exemplos a seguir mostram as aplicações mais comuns para as funções dessa biblioteca. Para uma referência completa consulte a documentação disponível na pasta <code>docs</code> de sua distribuição do compilador MaiaScript.</p>
<pre><code>// Callback.
trainingCallback(epochs, RSS, correctness, ETL) {
    system.println(&quot;Epochs: &quot; + core.toString(epochs) + &quot;, RSS: &quot; + core.toString(RSS) + &quot;, Correctness: &quot; + core.toString(correctness) + &quot;, ETL: &quot; + core.toString(ETL))
}

// Dados para treinar.
// O algoritmo de treinamento espera uma matriz com uma linha para cada dado e uma coluna para cada neurônio de entrada ou saída.
dataX = [[0.00],[0.25],[0.50],[0.75],[1.00],[1.25],[1.50],[1.75],[2.00],[2.25],[2.50],[2.75],[3.00],[3.25],[3.50],[3.75],[4.00],[4.25],[4.50],[4.75],[5.00],[5.25],[5.50],[5.75],[6.00],[6.25],[6.50],[6.75],[7.00],[7.25],[7.50],[7.75],[8.00],[8.25],[8.50],[8.75],[9.00],[9.25],[9.50],[9.75],[10.00]]
dataY = [[2.0000],[2.2197],[2.3811],[2.5136],[2.7310],[2.7827],[2.8327],[3.0351],[2.9551],[3.3973],[3.5117],[3.5909],[3.7345],[3.8419],[4.0952],[4.2879],[4.4000],[4.8764],[5.2843],[5.9241],[6.3302],[6.9608],[7.3044],[7.6791],[8.2819],[9.0139],[9.3387],[10.0420],[10.4000],[10.6437],[10.4786],[10.4928],[10.7082],[10.6233],[10.8862],[10.6830],[10.8393],[10.9186],[10.8814],[10.9779],[11.0000]]

nData = core.length(dataX)

// Cria uma rede neural Perceptron multicamadas.
nn = ann.createANN(&quot;mlp&quot;, 0, 0, 0, 0, 1, 1, 1, 3)
// Displays the untrained neural network.
system.println(&quot;ANN before be prepared: &quot; + core.toString(nn))
system.println(core.toString(ann.getLabels(nn)))

// Atribui pesos iniciais aleatórios às sinapses neurais.
nn = ann.prepare(nn, true, true, true)
system.println(core.toString(&quot;ANN after be prepared: &quot; + core.toString(nn)))

// Treina a rede neural.
statistics = ann.training(nn, dataX, dataY, 0.005, &quot;tanh&quot;, &quot;linear&quot;, &quot;none&quot;, [1, 0], 2000, 0.001, trainingCallback, 100)
// Displays training statistics.
// system.println(&quot;Statistics: &quot; + core.toString(statistics))

// Exibe a rede neural treinada.
system.println(&quot;Trained ANN: &quot; + core.toString(nn))

// Usa a rede treinada para estimar o valor da função.

system.println(&quot;The output must be f(0.50) = 2.3811&quot;)
out = ann.think(nn, [0.50], 1, 1, &quot;tanh&quot;, &quot;linear&quot;, &quot;none&quot;, [1, 0])
system.println(&quot;ANN for f(0.50): &quot; + core.toString(nn))
system.println(&quot;f(0.50) = &quot; + out[0])

system.println(&quot;The output must be f(1.25) = 2.7827&quot;)
out = ann.think(nn, [1.25], 1, 1, &quot;tanh&quot;, &quot;linear&quot;, &quot;none&quot;, [1, 0])
system.println(&quot;ANN for f(1.25): &quot; + core.toString(nn))
system.println(&quot;f(1.25) = &quot; + out[0])

system.println(&quot;The output must be f(5.00) = 6.3302&quot;)
out = ann.think(nn, [5.00], 1, 1, &quot;tanh&quot;, &quot;linear&quot;, &quot;none&quot;, [1, 0])
system.println(&quot;ANN for f(5.00): &quot; + core.toString(nn))
system.println(&quot;f(5.00) = &quot; + out[0])

system.println(&quot;The output must be f(5.1267) = 6.65671&quot;)
out = ann.think(nn, [5.1267], 1, 1, &quot;tanh&quot;, &quot;linear&quot;, &quot;none&quot;, [1, 0])
system.println(&quot;ANN for f(5.1267): &quot; + core.toString(nn))
system.println(&quot;f(5.1267) = &quot; + out[0])
</code></pre>
<h2 id="banco-de-dados-sql">Banco de dados SQL</h2>
<p>MaiaScript suporta nativamente o banco de dados <strong>SQLite</strong> mas pode utilizar qualquer banco de dados suportado pelo <strong>Node.js</strong>. Esses recursos estão disponíveis na biblioteca <code>core</code>. O exemplo a seguir cria um banco de dados, uma tabela e insere dados na tabela criada. Para uma referência completa consulte a documentação disponível na pasta <code>docs</code> de sua distribuição do compilador MaiaScript.</p>
<pre><code>dataHandler(transaction, results) {
}

errorHandler(transaction, error) {
}

createTable(transaction) {
    scheme = &quot;&quot;
    scheme = scheme + &quot;CREATE TABLE people(id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,&quot;
    scheme = scheme + &quot;name TEXT NOT NULL DEFAULT &#39;John Doe&#39;,&quot;
    scheme = scheme + &quot;shirt TEXT NOT NULL DEFAULT &#39;Purple&#39;);&quot;
    transaction.executeSql(scheme, [], dataHandler, errorHandler)
    transaction.executeSql(&quot;insert into people (name, shirt) VALUES (&#39;Joe&#39;, &#39;Green&#39;);&quot;, [], dataHandler, errorHandler)
    transaction.executeSql(&quot;insert into people (name, shirt) VALUES (&#39;Mark&#39;, &#39;Blue&#39;);&quot;, [], dataHandler, errorHandler)
    transaction.executeSql(&quot;insert into people (name, shirt) VALUES (&#39;Phil&#39;, &#39;Orange&#39;);&quot;, [], dataHandler, errorHandler)
    transaction.executeSql(&quot;insert into people (name, shirt) VALUES (&#39;jdoe&#39;, &#39;Purple&#39;);&quot;, [], dataHandler, errorHandler)
}

// Abre o banco de dados se ele existir ou cria um novo caso ele não exista.
db = core.openSQLDatabase(&quot;Test&quot;, &quot;1.0&quot;, &quot;Test&quot;, 65536)

// Cria uma tabela e insere dados nela.
if (typeof(db) != &quot;undefined&quot;) {
    db.transaction(createTable)
}
</code></pre>
<h2 id="programação-paralela-usando-gpu">Programação paralela usando GPU</h2>
<p>É possível acelerar o processamento em alguns problemas usando <strong>programação paralela</strong>. MaiaScript permite paralelismo real usando <strong>núcleos de GPU</strong> se este recurso estiver disponível na máquina hospedeira. Caso não esteja, o compilador MaiaScript compilará o programa para execução sequencial. Funções de computação em GPU são chamadas <em>shaders</em>. Essas funções são compiladas de modo diferente pelo compilador MaiaScript e não suportam números complexos ou cálculos com matrizes. Os recursos de programação com GPU estão disponíveis na biblioteca <code>gpu</code>. Para uma referência completa consulte a documentação disponível na pasta <code>docs</code> de sua distribuição do compilador MaiaScript.</p>
<p>O exemplo a seguir mostra como criar uma função para multiplicação paralela de duas matrizes. Também é implementada uma versão sequencial do cálculo para comparação de desempenho.</p>
<pre><code>// Crie duas matrizes de 512x512.
a = core.zero(512, 512)
b = core.zero(512, 512)

// Preenche as matrizes.
for (i = 0; i &lt; 512; i = i + 1) {
    for (j = 0; j &lt; 512; j = j + 1) {
        v = i * 512 + j
        a[i, j] = v
        b[i, j] = v
    }
}

// Função paralela.
shader #= (a, b) {
    local sum = 0
    for (local i = 0; i &lt; 512; i = i + 1) {
        sum = sum + a[this.thread.y, i] * b[i, this.thread.x]
    }
    return(sum)
}

// Função de computação usando a GPU.
useGPU ?= () {
    device = gpu.new()
    multiplyMatrices = device.createKernel(shader)
    multiplyMatrices.setOutput([512, 512])
    
    startTime := Date()
    c = multiplyMatrices(a, b)
    endTime := Date()
    
    elapsedTime = endTime - startTime
    
    system.log(&quot;GPU result:&quot;)
    system.log(&quot;c[511,511]: &quot; + c[511,511])
    system.log(&quot;Elapsed time: &quot; + elapsedTime + &quot; ms\n&quot;)
}

// Função de computação usando a CPU.
useCPU ?= () {
    startTime := Date()
    d = core.zero(512, 512)
    for (i = 0; i &lt; 512; i = i + 1) {
        for (j = 0; j &lt; 512; j = j + 1) {
            s = 0
            for (k = 0; k &lt; 512; k = k + 1) {
                s = s + a[i, k] * b[k, j]
            }
            d[i, j] = s
        }
    }
    endTime := Date()
    
    elapsedTime = endTime - startTime
    
    system.log(&quot;CPU result:&quot;)
    system.log(&quot;d[511,511]: &quot; + d[511,511])
    system.log(&quot;Elapsed time: &quot; + elapsedTime + &quot; ms\n&quot;)
}

// Iniciar cálculo.
useGPU()
useCPU()
</code></pre>
<h2 id="estatística-avançada">Estatística avançada</h2>
<p>MaiaScript oferece diversas funções estatísticas para operações com <strong>matrizes</strong> e arquivos <strong>CSV</strong>. Essas funções estão disponíveis nas bibliotecas <code>matrix</code>, <code>statistics</code> e <code>dfa</code>. A biblioteca <code>statistics</code> implementa funções para cálculos de <strong>médias</strong>, <strong>desvios</strong> e <strong>erros padrões</strong>, além de funções envolvendo <strong>números aleatórios</strong> e <strong>distribuição normal</strong>, incluído o cálculo da <strong>inversa da distribuição normal</strong>. A biblioteca <code>dfa</code> implementa cálculos de <strong>DFA</strong>, <strong>DCCA</strong> e <strong>rhoDCCA</strong>. Para uma referência completa consulte a documentação disponível na pasta <code>docs</code> de sua distribuição do compilador MaiaScript.</p>
<p>Os exemplos a seguir mostram aplicações comuns para as funções da biblioteca estatística:</p>
<pre><code>a = [1,0,0;0,1,0;0,0,1]
b = [1,2,3;4,5,6;7,8,9]
c = [2,3,-1;4,4,-3;2,-3,1]
d = core.matrix(0, 1, 3)
e = core.matrix(0, 3, 3)
avg = matrix.avg(b)
system.println(&quot;avg(b) = &quot; + avg.avg + &quot;, dev(b) = &quot; + avg.dev)
system.println(&quot;count(a) = &quot; + matrix.count(a))
system.println(&quot;max(b) = &quot; + matrix.max(b))
system.println(&quot;min(b) = &quot; + matrix.min(b))
system.println(&quot;trans(b) = &quot; + core.toString(matrix.trans(b)))
system.println(&quot;det(c) = &quot; + core.det(c))
system.println(&quot;diag(c) = &quot; + core.toString(core.diag(c)))
system.println(&quot;triang(c) = &quot; + core.toString(matrix.triang(c)))
system.println(&quot;cross([1,2,3], [4,5,6]) = &quot; + core.toString(matrix.cross([1,2,3], [4,5,6])))
system.println(&quot;dot([1,2,5], [2,-7,12]) = &quot; + core.toString(matrix.dot([1,2,5], [2,-7,12])))
system.println(&quot;dim([1,2,3]) = &quot; + core.toString(core.dim([1,2,3])))
system.println(&quot;d = &quot; + core.toString(d))
system.println(&quot;e = &quot; + core.toString(e))
</code></pre>
<h2 id="computação-algébrica">Computação algébrica</h2>
<p>MaiaScript possui um <strong>CAS (Computer Algebra System)</strong> completo implementado na biblioteca <code>cas</code>. Esse CAS permite simplificar expressões, resolver equações e realizar operações complexas de álgebra linear e cálculo diferencial e integral. O CAS é baseado na biblioteca <em>open source</em> <strong>Algebrite</strong>. Para uma referência completa consulte a documentação oficial do projeto Algebrite em <a href="http://algebrite.org">http://algebrite.org</a>. A única excessão é que o Algebrite originalmente utiliza o operador <code>ˆ</code> para potenciação e em MaiaScript o operador de potenciação é <code>**</code>. Os exemplos a seguir mostram como realizar as operações mais comuns de cálculo com o CAS MaiaScript:</p>
<pre><code>// Resolve uma expressão algébrica.
res = cas.eval(&quot;x + x&quot;)
system.showMessageDialog(&quot;x + x:\n\n&quot; + res)

// Simplifica uma expressão.
res = cas.eval(&quot;simplify(cos(x)**2 + sin(x)**2)\n&quot; +
               &quot;simplify(a*b+a*c)\n&quot; +
               &quot;simplify(n!/(n+1)!)&quot;)
system.showMessageDialog(&quot;simplify(cos(x)**2 + sin(x)**2)\n&quot; +
                         &quot;simplify(a*b+a*c)\n&quot; +
                         &quot;simplify(n!/(n+1)!):\n\n&quot; + res)

// Calcula a integral de uma expressão.
res = cas.eval(&quot;integral(x**2)\n&quot; +
               &quot;integral(x*y,x,y)&quot;)
system.showMessageDialog(&quot;integral(x**2)\n&quot; +
                         &quot;integral(x*y,x,y):\n\n&quot; + res)

// Calcula a derivada de uma expressão.
res = cas.eval(&quot;d(x**2)\n&quot; +
               &quot;r=sqrt(x**2+y**2)\n&quot; +
               &quot;d(r,[x,y])&quot;)
system.showMessageDialog(&quot;d(x**2)\n&quot; +
                         &quot;r=sqrt(x**2+y**2)\n&quot; +
                         &quot;d(r,[x,y])\n\n&quot; + res)
</code></pre>
</body></html>